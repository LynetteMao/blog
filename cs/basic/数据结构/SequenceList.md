---
title: 顺序表
date: 2019-5-14
tags: 数据结构
categories: 基础知识
toc: true
---


# 一、C语言基础
## 1. 指针
### 1.1 存储方式
在内存中数据由低位到高位进行存储，那么CPU如何对数据进行存取？
每一个字节的存储到主存中，都是有一个地址的。
定义不同的类型就会分配不同的存储空间，int类型分配4个字节，char类型分配一个字节。  
![sequenceList](http://prdj7tprx.bkt.clouddn.com/sequenceList.png)   

计算机的存储方式是两个地址相加而成的，因为计算机中的物理地址为20位，寄存器存放为16位，要用16位的寄存器来表示20位的物理地址，就通过分段的方式，用两个寄存器，其中一个表示段的首地址，将首地址*16(向左移动四位)就可以表示为20位，然后另一个寄存器表示段内的偏移地址，偏移量为从0到2^16.所以数组的开头为0，而不是1，是为了更好的表示偏移量。
### 1.2 指针存储方式
```c
int a;//分配了4个字节的存储空间
int *p;//p为指向int类型的指针
p=&a;//p存储了a的首地址，也即p指向了a
a=5;
```
### 1.3 &和*
&为取地址符，*有两种用法，一种是在定义的时候表示定义一个指针类型，一种是通过地址找到对应的值。
```c
//上面的定义方式也可以简写成
int a=5;
int* p = &a;

p=p+1;  //这个时候如果p为2002，那么p+1为2006，因为int类型占了4个字节
```
## 2. 结构
struct用于存储一个结构，一个结构里面可以包含有多个信息。
### 2.1 结构声明与定义
声明是告诉编译器如何表示数据，并未让编译器分配空间。在定义的时候，即创建一个结构变量，此时为改模板分配了变量。
```c
//第一种
//先对结构进行声明
struct List{
    int *data;
    int length;
    int max;
};
//再对结构进行定义
struct List array;

//第二种
struct List{
    int *data;
    int length;
    int max;
}array;
```
### 2.2 结构的表示方式
可以用指针访问结构，也可直接用结构的类型访问。
```c
struct List{
    int *data;
    int length;
    int max;
}*L;


L->length //指针访问结构内数据
List.length 
```

## 3. malloc()和free()
内存的分配分为静态分配和动态分配，静态分配即直接分配一段大小固定的连续空间，但是静态分配往往不能满足我们的需求  
虚拟内存部分是一个很大的模块，我还没有完全搞懂，等复习到操作系统的时候再把这个坑补上     
malloc是在堆上分配内存，注意：此处的堆不是数据结构中堆，这是虚拟内存中进程内存结构中的一部分。称作堆是因为它是可以让程序员可以调用也可以释放的一堆内存空间，但是如果不能掌握堆的用法，很可能会倒是内存泄漏。堆上的数据是要手动进行是释放，堆上向上增长的。   

malloc()是在内存不足的时候，调用其函数，有以下集中分配方式：   
1. malloc会先从free后的空闲列表中的内存块中找可以分配的内存，在此内存中前面一部分为存储内存块长度，后一部分为调用者可用的内存，此时返回的地址，为调用者可用内存的首地址。
2. 若空闲类别中的内存块不足够分配内存，则去内存中寻找连续的一段空间，返回值如上。
   
malloc()返回类型为void*，即返回分配空间中可用地址的首地址，调用的时候需要一个指针来接收此首地址，才能对申请的空间进行使用。在用完后需要使用free()进行释放，如果在一个作用域内没有使用free()进行释放，但是其指向此空间的指针已经在栈里面释放了，也就是此段内存无法进行访问，也无法释放了。
## 4.三种表示数组的方法
当用malloc()申请了一段内存，
```c
int *a;
//a指向了分配的内存的首地址,分配了3个int类型连续的内存
a = (int *)malloc(sizeof(int)*3);
//因为分配的内存是连续的，将分配的内存看作一个数组，a可以直接对此内存进行访问
a[0]=2; //对此段内存的前4个字节进行赋值。
printf("%d"，a[0];    //a[0]=2
```


创建数组的三种方式：
1. 声明数组时，用常量表达式表示数组的维度，用静态内存或者自动内存创建
2. 声明变长数组，用变量表达式表示数组的维度，用数组名访问数组元素
3. 声明指针，调用malloc()，将其返回值赋给指针，使用指针访问数组元素

# 二、顺序表

顺序表有两种存储方式，一种是静态存储，就是直接固定大小
还有一种就是动态分配内存。   
详细代码实现见github仓库  

## 定义数据结构
此数据结构，只需要分配这一个数据结构的空间，在此数据结构中含有一个int类型的数组，使用的时malloc()的调用方式来表示数组。
```c
typedef struct SeqList{
    int *data;  //定义了一个int类型的数组
    int Length;
    int Max;
}*L;

```

## 插入
1. 基础实现
   在位置i(i从1开始)插入数据e,则i开始全部数据往后移，再将e插入。其容易出错的地方在于数据往后移的for循环判断，注意数组是从0开始，而i和Length是从1开始，且这个数据后移，需要从最后一位开始往后移，不然会进行覆盖。a[Length]=a[Length-1],下标从Length开始，到i结束循环
   ```c
   for(j=L->Length;j>=i;j--){
       L->data[j]=L->data[j-1];
   }
   ```
   时间复杂度：  
   最坏情况：O(n)
   最好情况:O(1)
   平均情况：O(n)
2. 高效实现
   如果在位置i处插入数据e，将a[Length]=a[i-1],即将要插入的地方的数据加到整个数组的末尾，然后空出的此为主放置数据e。   
   时间复杂度：O(1)

## 删除
1. 基础实现
   基本和插入差不多，只是数据向上移动，同样容易错的地方在于for循环的判断条件，这个时候就要正序的往上移动。最一开始a[i-1]=a[i]到a[length-2]=a[length-1],j从i到j=length-1，所以j=i,j < length,j++,代码实现
   ```c
   for(j=i-1;j< L->Length;j++){
       L->data[j-1]=L->data[j];
   }
   ```
    时间复杂度：  
   最坏情况：O(n)
   最好情况:O(1)
   平均情况：O(n)
2. 高效实现
    如果删除一次，就对数组进行一次移动会造成大量的资源浪费，即可以先将删除的数据记录下来，进行统一删除，这也是JVM算法回收机制的原理。

